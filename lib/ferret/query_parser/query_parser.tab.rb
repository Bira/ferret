#
# DO NOT MODIFY!!!!
# This file is automatically generated by racc 1.4.4
# from racc grammer file "query_parser.y".
#

require 'racc/parser'


module Ferret

  class QueryParser < Racc::Parser

module_eval <<'..end query_parser.y modeval..id434256b68d', 'query_parser.y', 120
  attr_accessor :default_field

  # true if you want to downcase wild card queries. This is set to try by
  # default.
  attr_accessor :wild_lower

  def wild_lower?() @wild_lower end


  def initialize(default_field = "", options = {})
    @yydebug = true
    @field = @default_field = default_field
    @analyzer = options[:analyzer] || Analysis::Analyzer.new
    @wild_lower = options[:wild_lower].nil? ? true : options[:wild_lower]
    @occur_default = options[:occur_default] || BooleanClause::Occur::SHOULD
    @default_slop = options[:default_slop] || 0
  end

  RESERVED = {
    'AND'    => :AND,
    '&&'     => :AND,
    'OR'     => :OR,
    '||'     => :OR,
    'NOT'    => :NOT,
    '!'      => :NOT,
    '-'      => :NOT,
    'REQ'    => :REQ,
    '+'      => :REQ
  }

  ECHR =  %q,:()\[\]{}!+"~^\-\|<>\=\*\?,
  EWCHR = %q,:()\[\]{}!+"~^\-\|<>\=,

  def parse(str)
    str = clean_string(str)
    str.strip!
    @q = []

    until str.empty? do
      case str
      when /\A\s+/
        ;
      when /\A[#{ECHR}]/
        @q.push [ RESERVED[$&]||$&, $& ]
      when /\A(\&\&|\|\|)/
        @q.push [ RESERVED[$&], $& ]
      when /\A(\\[#{ECHR}]|[^\s#{ECHR}])+[?*](\\[#{EWCHR}]|[^\s#{EWCHR}])*/
        str = $'
        unescaped = $&.gsub(/\\(?!\\)/,"")
        @q.push [ :WILD_STRING, unescaped ]
        next
      when /\A(\\[#{ECHR}]|[^\s#{ECHR}])+/
        symbol = RESERVED[$&]
        if symbol
          @q.push [ symbol, $& ]
        else
          str = $'
          unescaped = $&.gsub(/\\(?!\\)/,"")
          @q.push [ :WORD, unescaped ]
          next
        end
      else
        raise RuntimeError, "shouldn't happen"
      end
      str = $'
    end
    @q.push [ false, '$' ]
    #p @q

    do_parse
  end

  def next_token
    @q.shift
  end

  PHRASE_CHARS = [?<, ?>, ?|, ?"] # these chars have meaning within phrases
  def clean_string(str)
    escape_chars = ECHR.gsub(/\\/,"").unpack("c*")
    pb = nil
    br_stack = []
    quote_open = false
    # leave a little extra
    new_str = []

    str.each_byte do |b|
      # ignore escaped characters
      if pb == ?\\
        if quote_open and PHRASE_CHARS.index(b)
          new_str << ?\\ # this was left off the first time through
        end

        new_str << b
        pb = (b == ?\\ ? ?: : b) # \\ has escaped itself so does nothing more
        next
      end
      case b
      when ?\\
        new_str << b if !quote_open # We do our own escaping below
      when ?"
        quote_open = !quote_open
        new_str << b
      when ?(
        if !quote_open
          br_stack << b
        else
          new_str << ?\\
        end
        new_str << b
      when ?)
        if !quote_open
          if br_stack.size == 0
            new_str.unshift(?()
          else
            br_stack.pop
          end
        else
          new_str << ?\\
        end
        new_str << b
      when ?>
        if quote_open
          if pb == ?<
            new_str.delete_at(-2)
          else
            new_str << ?\\
          end
        end
        new_str << b
      else
        if quote_open
          if escape_chars.index(b) and b != ?|
            new_str << ?\\
          end
        end
        new_str << b
      end
      pb = b
    end
    new_str << ?" if quote_open
    br_stack.each { |b| new_str << ?) }
    return new_str.pack("c*")  
  end

  def get_range_query(start_word, end_word, inc_upper, inc_lower)
    return RangeQuery.new(@field, start_word, end_word, inc_upper, inc_lower)
  end

  def get_term_query(word)
    tokens = []
    stream = @analyzer.token_stream(@field, word)
    while token = stream.next
      tokens << token
    end
    if tokens.length == 0
      return nil
    elsif tokens.length == 1
      return TermQuery.new(Term.new(@field, tokens[0].term_text))
    else
      pq = PhraseQuery.new()
      tokens.each do |token|
        pq.add(Term.new(@field, token.term_text), nil, token.position_increment)
      end
      return pq
    end
  end

  def get_fuzzy_query(word, min_sim = nil)
    tokens = []
    stream = @analyzer.token_stream(@field, word)
    if token = stream.next # only makes sense to look at one term for fuzzy
      if min_sim
        return FuzzyQuery.new(Term.new(@field, token.term_text), min_sim.to_f)
      else
        return FuzzyQuery.new(Term.new(@field, token.term_text))
      end
    else
      return nil
    end
  end

  def add_multi_word(words, word)
    last_word = words[-1]
    if not last_word.is_a?(Array)
      last_word = words[-1] = [words[-1]]
    end
    last_word << word
    return words
  end

  def get_normal_phrase_query(positions)
    pq = PhraseQuery.new()
    pq.slop = @default_slop
    pos_inc = 0

    positions.each do |position|
      if position.nil?
        pos_inc += 1
        next
      end
      stream = @analyzer.token_stream(@field, position)
      tokens = []
      while token = stream.next
        tokens << token
      end
      tokens.each do |token|
        pq.add(Term.new(@field, token.term_text), nil,
               token.position_increment + pos_inc)
        pos_inc = 0
      end
    end
    return pq
  end

  def get_multi_phrase_query(positions)
    mpq = MultiPhraseQuery.new()
    mpq.slop = @default_slop
    pos_inc = 0

    positions.each do |position|
      if position.nil?
        pos_inc += 1
        next
      end
      if position.is_a?(Array)
        position.compact! # it doesn't make sense to have an empty spot here
        terms = []
        position.each do |word|
          stream = @analyzer.token_stream(@field, word)
          if token = stream.next # only put one term per word
            terms << Term.new(@field, token.term_text)
          end
        end
        mpq.add(terms, nil, pos_inc + 1) # must go at least one forward
        pos_inc = 0
      else
        stream = @analyzer.token_stream(@field, position)
        tokens = []
        while token = stream.next
          tokens << token
        end
        tokens.each do |token|
          mpq.add([Term.new(@field, token.term_text)], nil,
                 token.position_increment + pos_inc)
          pos_inc = 0
        end
      end
    end
    return mpq
  end

  def get_phrase_query(positions, slop = nil)
    if positions.size == 1 and not positions[0].is_a?(Array)
      return get_term_query(words[0])
    end

    multi_phrase = false
    positions.each do |position|
      if position.is_a?(Array)
        position.compact!
        if position.size > 1
          multi_phrase = true
        end
      end
    end

    q = nil
    if not multi_phrase
      q = get_normal_phrase_query(positions.flatten)
    else
      q = get_multi_phrase_query(positions)
    end
    q.slop = slop if slop
    return q
  end

  def add_and_clause(clauses, clause)
    clauses.compact!
    if (clauses.length == 1)
      last_cl = clauses[0]
      last_cl.occur = BooleanClause::Occur::MUST if not last_cl.prohibited?
    end

    return if clause.nil? # incase a query got destroyed by the analyzer

    clause.occur = BooleanClause::Occur::MUST if not clause.prohibited?
    clauses << clause
  end

  def add_or_clause(clauses, clause)
    clauses << clause
  end

  def add_default_clause(clauses, clause)
    if @occur_default == BooleanClause::Occur::MUST
      add_and_clause(clauses, clause)
    else
      add_or_clause(clauses, clause)
    end
  end

  def get_boolean_query(clauses)
    # possible that we got all nil clauses so check
    return nil if clauses.nil?
    clauses.compact!
    return nil if clauses.size == 0

    if clauses.size == 1 and not clauses[0].prohibited?
      return clauses[0].query
    end
    bq = BooleanQuery.new()
    clauses.each {|clause|   bq << clause }
    return bq                
  end                        
                             
  def get_boolean_clause(query, occur)
    return nil if query.nil?
    return BooleanClause.new(query, occur)
  end

..end query_parser.y modeval..id434256b68d

##### racc 1.4.4 generates ###

racc_reduce_table = [
 0, 0, :racc_error,
 1, 25, :_reduce_1,
 1, 26, :_reduce_2,
 3, 26, :_reduce_3,
 3, 26, :_reduce_4,
 2, 26, :_reduce_5,
 2, 27, :_reduce_6,
 2, 27, :_reduce_7,
 1, 27, :_reduce_8,
 1, 29, :_reduce_none,
 3, 29, :_reduce_10,
 1, 28, :_reduce_none,
 3, 28, :_reduce_12,
 1, 28, :_reduce_none,
 1, 28, :_reduce_none,
 1, 28, :_reduce_none,
 1, 28, :_reduce_none,
 1, 30, :_reduce_17,
 3, 30, :_reduce_18,
 2, 30, :_reduce_19,
 1, 34, :_reduce_20,
 0, 36, :_reduce_21,
 4, 31, :_reduce_22,
 1, 35, :_reduce_23,
 3, 32, :_reduce_24,
 5, 32, :_reduce_25,
 2, 32, :_reduce_26,
 4, 32, :_reduce_27,
 1, 37, :_reduce_28,
 2, 37, :_reduce_29,
 3, 37, :_reduce_30,
 3, 37, :_reduce_31,
 4, 33, :_reduce_32,
 4, 33, :_reduce_33,
 4, 33, :_reduce_34,
 4, 33, :_reduce_35,
 3, 33, :_reduce_36,
 3, 33, :_reduce_37,
 3, 33, :_reduce_38,
 3, 33, :_reduce_39,
 2, 33, :_reduce_40,
 3, 33, :_reduce_41,
 3, 33, :_reduce_42,
 2, 33, :_reduce_43 ]

racc_reduce_n = 44

racc_shift_n = 73

racc_action_table = [
     7,    10,    61,    47,    38,    36,    48,    21,     3,    41,
    60,     6,     9,    12,    14,    16,    18,    37,    35,     1,
     7,    10,    33,    34,    58,    59,    40,    21,     3,    45,
   -23,     6,     9,    12,    14,    16,    18,     7,    10,     1,
    55,    42,    30,    56,    21,     3,    44,    28,     6,     9,
    12,    14,    16,    18,    43,    57,     1,     7,    10,    33,
    34,    70,    71,    39,    21,     3,    63,    64,     6,     9,
    12,    14,    16,    18,     7,    10,     1,    27,    62,    25,
    66,    21,     3,    67,    68,     6,     9,    12,    14,    16,
    18,     7,    10,     1,    69,    23,    72,   nil,    21,     3,
   nil,   nil,     6,     9,    12,    14,    16,    18,    21,     3,
     1,   nil,     6,     9,    12,    14,    16,    18,    21,     3,
     1,   nil,     6,     9,    12,    14,    16,    18,    21,     3,
     1,   nil,     6,     9,    12,    14,    16,    18,    52,   nil,
     1,   nil,   nil,    49,    50,   nil,    51 ]

racc_action_check = [
     0,     0,    41,    27,    14,    12,    28,     0,     0,    18,
    41,     0,     0,     0,     0,     0,     0,    14,    12,     0,
    24,    24,    24,    24,    40,    40,    16,    24,    24,    24,
    21,    24,    24,    24,    24,    24,    24,     3,     3,    24,
    35,    21,     9,    37,     3,     3,    23,     9,     3,     3,
     3,     3,     3,     3,    23,    39,     3,    11,    11,    11,
    11,    61,    61,    15,    11,    11,    44,    44,    11,    11,
    11,    11,    11,    11,    34,    34,    11,     8,    42,     5,
    48,    34,    34,    49,    50,    34,    34,    34,    34,    34,
    34,    33,    33,    34,    51,     1,    67,   nil,    33,    33,
   nil,   nil,    33,    33,    33,    33,    33,    33,    10,    10,
    33,   nil,    10,    10,    10,    10,    10,    10,    25,    25,
    10,   nil,    25,    25,    25,    25,    25,    25,     7,     7,
    25,   nil,     7,     7,     7,     7,     7,     7,    29,   nil,
     7,   nil,   nil,    29,    29,   nil,    29 ]

racc_action_pointer = [
    -3,    85,   nil,    34,   nil,    77,   nil,   118,    77,    32,
    98,    54,    -5,   nil,    -6,    54,    16,   nil,    -1,   nil,
   nil,    28,   nil,    36,    17,   108,   nil,     3,    -7,   128,
   nil,   nil,   nil,    88,    71,    30,   nil,    33,   nil,    45,
     4,    -8,    68,   nil,    46,   nil,   nil,   nil,    70,    70,
    67,    84,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,    41,   nil,   nil,   nil,   nil,   nil,    86,   nil,   nil,
   nil,   nil,   nil ]

racc_action_default = [
   -44,   -44,   -15,   -44,   -16,   -44,   -20,   -44,   -44,   -44,
   -44,    -1,   -44,    -2,   -44,    -9,   -44,    -8,   -44,   -11,
   -13,   -17,   -14,   -44,   -44,   -44,    -6,   -44,   -26,   -44,
   -28,    -7,    -5,   -44,   -44,   -44,   -40,   -44,   -43,   -44,
   -44,   -44,   -19,   -39,   -44,   -12,   -21,    73,   -44,   -24,
   -44,   -44,   -29,    -3,    -4,   -41,   -42,   -10,   -37,   -36,
   -38,   -44,   -18,   -34,   -35,   -22,   -27,   -44,   -30,   -31,
   -32,   -33,   -25 ]

racc_goto_table = [
    32,    26,    11,     8,    31,    24,    65,    29,   nil,   nil,
   nil,   nil,   nil,    32,   nil,   nil,   nil,   nil,   nil,    46,
   nil,   nil,    53,    54 ]

racc_goto_check = [
     3,     4,     2,     1,     4,     2,    12,    13,   nil,   nil,
   nil,   nil,   nil,     3,   nil,   nil,   nil,   nil,   nil,     4,
   nil,   nil,     3,     3 ]

racc_goto_pointer = [
   nil,     3,     2,   -11,    -6,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   -40,    -2 ]

racc_goto_default = [
   nil,   nil,   nil,    13,    15,    17,    19,    20,    22,     2,
     4,     5,   nil,   nil ]

racc_token_table = {
 false => 0,
 Object.new => 1,
 ":" => 2,
 :REQ => 3,
 :NOT => 4,
 :AND => 5,
 :OR => 6,
 :HIGH => 7,
 :LOW => 8,
 "^" => 9,
 :WORD => 10,
 "(" => 11,
 ")" => 12,
 "~" => 13,
 :WILD_STRING => 14,
 "\"" => 15,
 "<" => 16,
 ">" => 17,
 "|" => 18,
 "[" => 19,
 "]" => 20,
 "}" => 21,
 "{" => 22,
 "=" => 23 }

racc_use_result_var = false

racc_nt_base = 24

Racc_arg = [
 racc_action_table,
 racc_action_check,
 racc_action_default,
 racc_action_pointer,
 racc_goto_table,
 racc_goto_check,
 racc_goto_default,
 racc_goto_pointer,
 racc_nt_base,
 racc_reduce_table,
 racc_token_table,
 racc_shift_n,
 racc_reduce_n,
 racc_use_result_var ]

Racc_token_to_s_table = [
'$end',
'error',
'":"',
'REQ',
'NOT',
'AND',
'OR',
'HIGH',
'LOW',
'"^"',
'WORD',
'"("',
'")"',
'"~"',
'WILD_STRING',
'"\""',
'"<"',
'">"',
'"|"',
'"["',
'"]"',
'"}"',
'"{"',
'"="',
'$start',
'top_query',
'bool_query',
'bool_clause',
'query',
'boosted_query',
'term_query',
'field_query',
'phrase_query',
'range_query',
'wild_query',
'field_name',
'@1',
'phrase_words']

Racc_debug_parser = false

##### racc system variables end #####

 # reduce 0 omitted

module_eval <<'.,.,', 'query_parser.y', 18
  def _reduce_1( val, _values)
                    get_boolean_query(val[0])
  end
.,.,

module_eval <<'.,.,', 'query_parser.y', 23
  def _reduce_2( val, _values)
                    [val[0]]
  end
.,.,

module_eval <<'.,.,', 'query_parser.y', 27
  def _reduce_3( val, _values)
                    add_and_clause(val[0], val[2])
  end
.,.,

module_eval <<'.,.,', 'query_parser.y', 31
  def _reduce_4( val, _values)
                    add_or_clause(val[0], val[2])
  end
.,.,

module_eval <<'.,.,', 'query_parser.y', 35
  def _reduce_5( val, _values)
                    add_default_clause(val[0], val[1])
  end
.,.,

module_eval <<'.,.,', 'query_parser.y', 40
  def _reduce_6( val, _values)
                    get_boolean_clause(val[1], BooleanClause::Occur::MUST)
  end
.,.,

module_eval <<'.,.,', 'query_parser.y', 44
  def _reduce_7( val, _values)
                    get_boolean_clause(val[1], BooleanClause::Occur::MUST_NOT)
  end
.,.,

module_eval <<'.,.,', 'query_parser.y', 48
  def _reduce_8( val, _values)
                    get_boolean_clause(val[0], BooleanClause::Occur::SHOULD)
  end
.,.,

 # reduce 9 omitted

module_eval <<'.,.,', 'query_parser.y', 50
  def _reduce_10( val, _values)
 val[0].boost = val[2].to_f; return val[0]
  end
.,.,

 # reduce 11 omitted

module_eval <<'.,.,', 'query_parser.y', 57
  def _reduce_12( val, _values)
                    get_boolean_query(val[1])
  end
.,.,

 # reduce 13 omitted

 # reduce 14 omitted

 # reduce 15 omitted

 # reduce 16 omitted

module_eval <<'.,.,', 'query_parser.y', 66
  def _reduce_17( val, _values)
                    get_term_query(val[0])
  end
.,.,

module_eval <<'.,.,', 'query_parser.y', 70
  def _reduce_18( val, _values)
                    get_fuzzy_query(val[0], val[2])
  end
.,.,

module_eval <<'.,.,', 'query_parser.y', 74
  def _reduce_19( val, _values)
                    get_fuzzy_query(val[0])
  end
.,.,

module_eval <<'.,.,', 'query_parser.y', 79
  def _reduce_20( val, _values)
                    WildcardQuery.new(Term.new(@field, val[0]))
  end
.,.,

module_eval <<'.,.,', 'query_parser.y', 80
  def _reduce_21( val, _values)
@field = @default_field
  end
.,.,

module_eval <<'.,.,', 'query_parser.y', 84
  def _reduce_22( val, _values)
                    val[2]
  end
.,.,

module_eval <<'.,.,', 'query_parser.y', 85
  def _reduce_23( val, _values)
 @field = val[0]
  end
.,.,

module_eval <<'.,.,', 'query_parser.y', 91
  def _reduce_24( val, _values)
                    get_phrase_query(val[1])
  end
.,.,

module_eval <<'.,.,', 'query_parser.y', 95
  def _reduce_25( val, _values)
                    get_phrase_query(val[1], val[4].to_i)
  end
.,.,

module_eval <<'.,.,', 'query_parser.y', 95
  def _reduce_26( val, _values)
 nil
  end
.,.,

module_eval <<'.,.,', 'query_parser.y', 96
  def _reduce_27( val, _values)
 nil
  end
.,.,

module_eval <<'.,.,', 'query_parser.y', 98
  def _reduce_28( val, _values)
 [val[0]]
  end
.,.,

module_eval <<'.,.,', 'query_parser.y', 99
  def _reduce_29( val, _values)
 val[0] << val[1]
  end
.,.,

module_eval <<'.,.,', 'query_parser.y', 100
  def _reduce_30( val, _values)
 val[0] << nil
  end
.,.,

module_eval <<'.,.,', 'query_parser.y', 101
  def _reduce_31( val, _values)
 add_multi_word(val[0], val[2])
  end
.,.,

module_eval <<'.,.,', 'query_parser.y', 103
  def _reduce_32( val, _values)
 get_range_query(val[1], val[2], true, true)
  end
.,.,

module_eval <<'.,.,', 'query_parser.y', 104
  def _reduce_33( val, _values)
 get_range_query(val[1], val[2], true, false)
  end
.,.,

module_eval <<'.,.,', 'query_parser.y', 105
  def _reduce_34( val, _values)
 get_range_query(val[1], val[2], false, true)
  end
.,.,

module_eval <<'.,.,', 'query_parser.y', 106
  def _reduce_35( val, _values)
 get_range_query(val[1], val[2], false, false)
  end
.,.,

module_eval <<'.,.,', 'query_parser.y', 107
  def _reduce_36( val, _values)
 get_range_query(nil,    val[1], false, false)
  end
.,.,

module_eval <<'.,.,', 'query_parser.y', 108
  def _reduce_37( val, _values)
 get_range_query(nil,    val[1], false, true)
  end
.,.,

module_eval <<'.,.,', 'query_parser.y', 109
  def _reduce_38( val, _values)
 get_range_query(val[1], nil,    true, false)
  end
.,.,

module_eval <<'.,.,', 'query_parser.y', 110
  def _reduce_39( val, _values)
 get_range_query(val[1], nil,    false, false)
  end
.,.,

module_eval <<'.,.,', 'query_parser.y', 111
  def _reduce_40( val, _values)
 get_range_query(nil,    val[1], false, false)
  end
.,.,

module_eval <<'.,.,', 'query_parser.y', 112
  def _reduce_41( val, _values)
 get_range_query(nil,    val[2], false, true)
  end
.,.,

module_eval <<'.,.,', 'query_parser.y', 113
  def _reduce_42( val, _values)
 get_range_query(val[2], nil,    true, false)
  end
.,.,

module_eval <<'.,.,', 'query_parser.y', 114
  def _reduce_43( val, _values)
 get_range_query(val[1], nil,    false, false)
  end
.,.,

 def _reduce_none( val, _values)
  val[0]
 end

  end   # class QueryParser

end   # module Ferret


if __FILE__ == $0
  $:.unshift File.join(File.dirname(__FILE__), '..')
  require 'utils'
  require 'analysis'
  require 'document'
  require 'store'
  require 'index'
  require 'search'

  st = "\033[7m"
  en = "\033[m"

  parser = Ferret::QueryParser.new("default")

  $stdin.each do |line|
    query = parser.parse(line)
    if query
      puts "#{query.class}"
      puts query.to_s(parser.default_field)
    else
      puts "No query was returned"
    end
  end
end
