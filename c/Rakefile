require 'set'
require 'erb'
require 'rake'
require 'rake/clean'

class String
  def /(path)
    File.join(self, path)
  end
end

DEP_EXT = '.dep'
def dep_file(src)
  TMP/File.basename(src) + DEP_EXT
end

def src2obj(src)
  src.pathmap("%{.*,}p%n.o")
end

def obj_map(srcs, prefix = '')
  srcs.map do |src|
    obj = prefix + src2obj(src)
    FILE2SRC[obj] = src
    obj
  end
end

def with_src(file)
  if src = FILE2SRC[file]
    yield src
  else
    puts "Sorry, I don't know anything about '#{file}'"
  end
end

def with_file(file, default=nil)
  if file.nil? and default
    yield default
  elsif File.exists?(file)
    yield file
  else
    puts "Sorry, I don't know anything about '#{file}'"
  end
end

def qsh(msg, script)
  puts "#{msg}..."
  `#{script}`
end

def vsh(msg, script)
  puts "#{msg}..."
  sh script
end


###
# Path Constants
###
TMP             = '.rake'
FILE2SRC        = {}

STEMMER_DIR     = 'lib/libstemmer_c'
STEMMER_INC_DIR = STEMMER_DIR / 'include'
STEMMER_SRCS    = FileList[STEMMER_DIR / 'src_c/*.c',
                           STEMMER_DIR / 'runtime/api.c',
                           STEMMER_DIR / 'runtime/utilities.c',
                           STEMMER_DIR / 'libstemmer/libstemmer.c']
STEMMER_OBJS    = obj_map(STEMMER_SRCS, 'lib/')

if ENV['USE_ZLIB'] or ENV['USE_CPP']
  BZLIB_INC_DIR = nil
  BZLIB_OBJS    = nil
else
  BZLIB_DIR     = 'lib/bzlib'
  BZLIB_INC_DIR = BZLIB_DIR
  BZLIB_SRCS    = FileList[BZLIB_DIR / '*.c']
  BZLIB_OBJS    = obj_map(BZLIB_SRCS, 'lib/')
end

SRCS            = FileList['src/*.c']
OBJS            = obj_map(SRCS)
INC_DIR         = 'include'

TEST_SRCS       = FileList['test/*.c']
TEST_OBJS       = obj_map(TEST_SRCS)

BENCHMARK_SRCS  = FileList['benchmark/*.c']
BENCHMARK_OBJS  = obj_map(BENCHMARK_SRCS)

INC_DIRS        = [STEMMER_INC_DIR, BZLIB_INC_DIR, INC_DIR,
                    'test', 'benchmark'].compact
INC_FILES       = FileList[*INC_DIRS.map{|dir| File.join(dir, '*.h')}]
INC_MAP         = INC_FILES.inject({}) {|h, f| h[File.basename(f)] = f;h}

SRC_FILES       = SRCS + TEST_SRCS + BENCHMARK_SRCS
ALL_BUILD_FILES = INC_FILES + SRC_FILES
ABF_BASENAMES   = ALL_BUILD_FILES.map do |src|
  basename = File.basename(src)
  FILE2SRC[dep_file(src)] = FILE2SRC[basename] = FILE2SRC[src] = src
end

###
# Create required directories
###
FileUtils.mkdir_p('test/testdir/store')
FileUtils.mkdir_p(TMP)

###
# Dependency Handling
###
DEP_L1_CACHE = Hash.new do |h, src|
  h[src] = File.read(src).scan(/# *include [<"](.*)[">]/).flatten.sort.uniq.
    map {|bn| FILE2SRC[bn]}.compact
end

def collect_src_deps(src, collector)
  collector[src] = true
  dep_srcs = DEP_L1_CACHE[src]
  dep_srcs.each do |dep_src|
    unless collector[dep_src]
      collector[dep_src] = true
      collect_src_deps(dep_src, collector)
    end
  end
end

def get_dep_srcs(src)
  df = dep_file(src)
  if File.exists?(df) and File.stat(src).mtime < (mtime = File.stat(df).mtime)
    dep_srcs = Marshal.load(File.read(df))
    return dep_srcs unless dep_srcs.find {|f| File.stat(f).mtime > mtime}
  end
  collector = {}
  collect_src_deps(src, collector)
  dep_srcs = collector.keys
  File.open(df, 'wb') {|f| f.write(Marshal.dump(dep_srcs))}
  dep_srcs
end

###
# Compilation Constants
###
CC       = 'gcc'
DEFS     = "-DBZ_NO_STDIO -D_FILE_OFFSET_BITS=64 -DDEBUG -D_POSIX_C_SOURCE=2"
AR       = "ar"
CINCS    = INC_DIRS.map{|d| "-I#{d}"}.join(' ')
LDFLAGS  = "-lm -lpthread -lz"
DEP_DIR  = ".deps"
GCOV_DIR = ".gcov"
CFLAGS   = "-pedantic -Wall -Wextra #{CINCS} -g -fno-common -std=c99 #{DEFS}"

if (File.exists?(`which gdb 2> /dev/null`.chomp))
  CFLAGS << " -DHAVE_GDB"
end

if ENV['USE_CPP']
  CC[1,2] = '++'
  CFLAGS.sub!(/-std=c99/, ' -DUSE_ZLIB')
  FileList['.rake/HAVE_*'].each {|fn| CFLAGS << File.read(fn)}
end


###
# Clean Constants
###
CLEAN  .include([ '*.o',
                  '**/*.gcda',
                  '**/*.gcno',
                  '*.gcov',
                  'y.tab.c'])

CLOBBER.include([ '*.a',
                  '**/*.o',
                  'testall',
                  '.rake/*',
                  'gmon.out',
                  DEP_DIR,
                  GCOV_DIR])

task :default => :test

desc "Run all tests"
task :test => 'testall' do
  sh "./testall -q -v"
end

namespace :build do
  desc "Build the Ferret library 'libferret.a'"
  task :lib => 'libferret.a'

  LIB_FERRET_OBJS = [OBJS, STEMMER_OBJS, BZLIB_OBJS].flatten.compact
  file "libferret.a" => LIB_FERRET_OBJS do |t|
    qsh "Generating library: #{t.name}",
        "#{AR} -cru #{t.name} #{t.prerequisites}"
  end

  desc "Build the test binary 'testall'"
  task :tests => 'testall'

  desc "Build the test runner"
  file "testall" => [LIB_FERRET_OBJS, TEST_OBJS].flatten do |t|
  #file "testall" => ['libferret.a', TEST_OBJS].flatten do |t|
    qsh "Building tests",
        "#{CC} #{CFLAGS} #{LDFLAGS} #{t.prerequisites} -o testall"
  end

  desc "Build the benchmark runner"
  file "bench" => [LIB_FERRET_OBJS, BENCHMARK_OBJS].flatten do |t|
    vsh "Building benchmarks",
        "#{CC} #{CFLAGS} #{LDFLAGS} #{t.prerequisites} -o bench"
  end

  file 'src/q_parser.c' => 'src/q_parser.y' do
    sh "yacc -o src/q_parser.c -p frt_ src/q_parser.y"
  end

  file 'src/scanner.c' => 'src/scanner.rl' do
    sh "ragel src/scanner.rl -o src/scanner.c"
  end

  file 'test/all_tests.h' => FileList['test/test_*.c'] do |t|
    File.open(t.name, 'w') do |f|
      tests = t.prerequisites.map{|fn|
        File.read(fn).scan(/TestSuite \*(ts_[_A-Za-z]+)/)
      }.flatten
      f.write(ERB.new(File.read('test/all_tests.erb')).result(binding))
    end
  end

  file 'benchmark/all_benchmarks.h' => FileList['benchmark/bm_*.c'] do |t|
    File.open(t.name, 'w') do |f|
      benchmarks = t.prerequisites.map{|fn|
        File.read(fn).scan(/BENCH\((\w+)\)/)
      }.flatten
      f.write(ERB.new(File.read('benchmark/all_benchmarks.erb')).result(binding))
    end
  end

  file 'include/internal.h' =>
        FileList['include/*.h'].exclude('include/internal.h') do |t|
    # read in all of the data removing the initial masking defines
    data = t.prerequisites.map {|f| File.read(f).sub(/^.*\n.*\n/, '')}.join
    File.open(t.name, 'w') do |f|
      f.write "#ifndef FRT_INTERNAL_H\n"
      f.write "#define FRT_INTERNAL_H\n"
      f.write "\n"

      [
        ['Constants', 'FRT_'],
        ['Types',     'Frt' ],
        ['Functions', 'frt_']
      ].each do |header, re|
        names = data.scan(/#{re}[A-Za-z0-9_]+/).sort.uniq
        next unless names and names.size > 0
        f.write "/* #{header} */\n"
        maxlen = names.map{|name| name.size}.max - re.size
        names.each do |name|
          f.write "#define %-#{maxlen}s #{name}\n" % name.sub(/^#{re}/, '')
        end
        f.write "\n"
      end
      f.write "#endif\n"
    end
  end

  rule '.o' => lambda {|obj| get_dep_srcs(FILE2SRC[obj])} do |t|
    qsh "Compiling #{t.name}",
        "#{CC} #{CFLAGS} -c -o #{t.name} #{FILE2SRC[t.name]}"
  end

  file '.rake/HAVE_SPARSE_HASH' => '.rake/have_sparse_hash.cpp' do |t|
    begin
      sh "g++ #{t.prerequisites}"
      File.open(t.name, 'w') {|f| f.write(' -DHAVE_SPARSE_HASH')}
    rescue
      File.open(t.name, 'w') {|f|}
    end
  end
end

task :valgrind => 'testall' do
	sh "valgrind --suppressions=valgrind.supp " +
                "--leak-check=yes             " +
                "--show-reachable=yes         " +
                "--workaround-gcc296-bugs=yes -v ./testall -q"
end

task :gen_valgrind => 'build:testall' do
	sh "valgrind --suppressions=valgrind.supp " +
                "--leak-check=yes             " +
                "--show-reachable=yes         " +
                "--gen-suppressions=yes       " +
                "--workaround-gcc296-bugs=yes -v ./testall -q"
end


namespace :show do
  task :dep, :src do |t, args|
    with_src(args.src) {|src| puts get_dep_srcs(src).sort.join("\n")}
  end

  task :'dep-l1', :src do |t, args|
    with_src(args.src) {|src| puts DEP_L1_CACHE[src].sort.join("\n")}
  end

  task :names, :file do |t, args|
    with_file(args.file, 'libferret.a') do |f|
      `nm -s #{f}`.split(/\n/).each do |l|
        puts l if l =~ /[0-9a-f]* +([-ABCDGINRSTUVW?])/
      end
    end
  end

  def badname?(l)
    l =~ /[0-9a-f]* +([-ABCDGINRSTVW?]) (.*)/ and
                  $2 !~ /^(Ferret|frt_|FRT_)/
  end

  task :badnames, :file do |t, args|
    with_file(args.file, 'libferret.a') do |f| Rake::Task[f].invoke
      `nm -s #{f}`.split(/\n/).each do |l|
        puts l if badname?(l)
      end
    end
  end

  task :'allbadnames' => OBJS do
    SRCS.each do |src|
      next if src =~ /posh\.c/
      obj = src2obj(src)
      badnames = `nm -s #{obj}`.split(/\n/).map do |l|
        '  ==> ' + l.sub(/.* /, '') if badname?(l)
      end.compact
      puts obj, *badnames if badnames.size > 0
    end
  end
end

desc "Look for TODO and FIXME tags in the code"
task :todo do
  FileList['**/*.[ch]'].egrep /[#*].*(FIXME|TODO|TBD)/i
end
