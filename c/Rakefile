require 'set'
require 'rake'
require 'rake/clean'

class String
  def /(path)
    File.join(self, path)
  end
end

DEP_EXT = '.dep'
def dep_file(src)
  TMP/File.basename(src) + DEP_EXT
end

def obj_map(srcs)
  srcs.map do |src|
    obj = src.pathmap("%{.*,}p%n.o")
    FILE2SRC[obj] = src
    obj
  end
end

def with_src(file)
  if src = FILE2SRC[file]
    yield src
  else
    puts "Sorry, I don't know anything about '#{file}'"
  end
end

def with_file(file, default=nil)
  if file.nil? and default
    yield default
  elsif File.exists?(file)
    yield file
  else
    puts "Sorry, I don't know anything about '#{file}'"
  end
end

def qsh(msg, script)
  puts "#{msg}..."
  `#{script}`
end

def vsh(msg, script)
  puts "#{msg}..."
  sh script
end


###
# Path Constants
###
TMP             = '.rake'
FILE2SRC        = {}

STEMMER_DIR     = 'lib/libstemmer_c'
STEMMER_INC_DIR = STEMMER_DIR / 'include'
STEMMER_SRCS    = FileList[STEMMER_DIR / 'src_c/*.c',
                           STEMMER_DIR / 'runtime/api.c',
                           STEMMER_DIR / 'runtime/utilities.c',
                           STEMMER_DIR / 'libstemmer/libstemmer.c']
STEMMER_OBJS    = obj_map(STEMMER_SRCS)

BZLIB_DIR       = 'lib/bzlib'
BZLIB_INC_DIR   = BZLIB_DIR
BZLIB_SRCS      = FileList[BZLIB_DIR / '*.c']
BZLIB_OBJS      = obj_map(BZLIB_SRCS)

SRCS            = FileList['src/*.c']
OBJS            = obj_map(SRCS)
INC_DIR         = 'include'

TEST_SRCS       = FileList['test/*.c']
TEST_OBJS       = obj_map(TEST_SRCS)

INC_DIRS        = [STEMMER_INC_DIR, BZLIB_INC_DIR, INC_DIR, 'test']
INC_FILES       = FileList[*INC_DIRS.map{|dir| File.join(dir, '*.h')}]
INC_MAP         = INC_FILES.inject({}) {|h, f| h[File.basename(f)] = f;h}

SRC_FILES       = SRCS + TEST_SRCS
ALL_BUILD_FILES = INC_FILES + SRC_FILES
ABF_BASENAMES   = ALL_BUILD_FILES.map do |src|
  basename = File.basename(src)
  FILE2SRC[dep_file(src)] = FILE2SRC[basename] = FILE2SRC[src] = src
end

###
# Create required directories
###
FileUtils.mkdir_p('test/testdir/store')
FileUtils.mkdir_p(TMP)

###
# Dependency Handling
###
DEP_L1_CACHE = Hash.new do |h, src|
  h[src] = File.read(src).scan(/# *include [<"](.*)[">]/).flatten.sort.uniq.
    map {|bn| FILE2SRC[bn]}.compact
end

def collect_src_deps(src, collector)
  collector[src] = true
  dep_srcs = DEP_L1_CACHE[src]
  dep_srcs.each do |dep_src|
    unless collector[dep_src]
      collector[dep_src] = true
      collect_src_deps(dep_src, collector)
    end
  end
end

def get_dep_srcs(src)
  df = dep_file(src)
  if File.exists?(df) and File.stat(src).mtime < (mtime = File.stat(df).mtime)
    dep_srcs = Marshal.load(File.read(df))
    return dep_srcs unless dep_srcs.find {|f| File.stat(f).mtime > mtime}
  end
  collector = {}
  collect_src_deps(src, collector)
  dep_srcs = collector.keys
  File.open(df, 'wb') {|f| f.write(Marshal.dump(dep_srcs))}
  dep_srcs
end

###
# Compilation Constants
###
AR       = "ar"
CC       = "gcc"
CINCS    = INC_DIRS.map{|d| "-I#{d}"}.join(' ')
DEFS     = "-DBZ_NO_STDIO -D_FILE_OFFSET_BITS=64 -DDEBUG -D_POSIX_C_SOURCE=2"
CFLAGS   = "-std=c99 -pedantic -Wall -Wextra #{CINCS} -g -fno-common #{DEFS}"
LDFLAGS  = "-lm -lpthread -lz"
DEP_DIR  = ".deps"
GCOV_DIR = ".gcov"


###
# Clean Constants
###
CLEAN  .include([ '*.o',
                  '*.gcda',
                  '*.gcov',
                  '*.gcno'])

CLOBBER.include([ '*.a',
                  '**/*.o',
                  'testall',
                  'load_bench',
                  'bench',
                  'search_bench',
                  'sort_bench',
                  '.rake/*',
                  'gmon.out',
                  DEP_DIR,
                  GCOV_DIR])

task :default => :test

desc "Run all tests"
task :test => 'testall' do
    sh "./testall"
end

namespace :build do
  desc "Build the Ferret library 'libferret.a'"
  task :lib => 'libferret.a'

  file "libferret.a" => [OBJS, STEMMER_OBJS, BZLIB_OBJS].flatten do |t|
    qsh "Generating library: #{t.name}",
        "#{AR} -cru #{t.name} #{t.prerequisites}"
  end

  desc "Build the test binary 'testall'"
  task :tests => 'testall'

  file "testall" => [TEST_OBJS, 'libferret.a'].flatten do |t|
    qsh "Building tests",
        "gcc #{CFLAGS} #{LDFLAGS} #{t.prerequisites} -o testall"
  end

  file 'include/internal.h' =>
        FileList['include/*.h'].exclude('include/internal.h') do |t|
    # read in all of the data removing the initial masking defines
    data = t.prerequisites.map {|f| File.read(f).sub(/^.*\n.*\n/, '')}.join
    File.open(t.name, 'w') do |f|
      f.write "#ifndef FRT_INTERNAL_H\n"
      f.write "#define FRT_INTERNAL_H\n"
      f.write "\n"

      [
        ['Constants',  'FRT_'   ],
        ['Types',      'Frt'    ],
        ['Functions',  'frt_'   ]
      ].each do |header, re|
        names = data.scan(/#{re}[A-Za-z0-9_]+/).sort.uniq
        next unless names and names.size > 0
        f.write "/* #{header} */\n"
        maxlen = names.map{|name| name.size}.max - re.size
        names.each do |name|
          f.write "#define %-#{maxlen}s #{name}\n" % name.sub(/^#{re}/, '')
        end
        f.write "\n"
      end
      f.write "#endif\n"
    end
  end

  rule '.o' => lambda {|obj| get_dep_srcs(FILE2SRC[obj])} do |t|
    qsh "Compiling #{t.name}",
        "gcc #{CFLAGS} -c -o #{t.name} #{FILE2SRC[t.name]}"
  end
end

namespace :show do
  task :dep, :src do |t, args|
    with_src(args.src) {|src| puts get_dep_srcs(src).sort.join("\n")}
  end

  task :'dep-l1', :src do |t, args|
    with_src(args.src) {|src| puts DEP_L1_CACHE[src].sort.join("\n")}
  end

  task :names, :file do |t, args|
    with_file(args.file, 'libferret.a') do |f|
      `nm -s #{f}`.split(/\n/).each do |l|
        puts l if l =~ /[0-9a-f]* +([-ABCDGINRSTUVW?])/
      end
    end
  end

  task :badnames, :file do |t, args|
    with_file(args.file, 'libferret.a') do |f|
      Rake::Task[f].invoke
      `nm -s #{f}`.split(/\n/).each do |l|
        puts l if l =~ /[0-9a-f]* +([-ABCDGINRSTVW?]) (.*)/ and
                  $2 !~ /^(Ferret|frt_|FRT_)/
      end
    end
  end
end

desc "Look for TODO and FIXME tags in the code"
task :todo do
  FileList['**/*.[ch]'].egrep /[#*].*(FIXME|TODO|TBD)/i
end
