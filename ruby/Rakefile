require 'rake'
require 'rake/clean'
require 'rake/gempackagetask'
require 'rake/rdoctask'
require 'rake/testtask'

$:. << 'lib'
require 'ferret/version'

def say(msg='')
  STDERR.puts msg
end

def prompt(msg)
  print "#{msg} [Yna]: "
  while true
    case gets.chomp!
    when /^(y(es)?)?$/i: return true
    when /^no?$/i: return false
    when /^a(bort)?$/i: fail('aborted')
    else
      puts "Sorry, didn't understand your answer. Please type y, n or a."
    end
  end
end

case gets.chomp!
when /^(y(es)?)?$/i: puts true
else
  puts false
end

task :default => 'test:unit'
#task :default => :build do
#  sh "ruby test/unit/index/tc_index.rb"
#end

##############################################################################
# Building
##############################################################################

task :build => 'build:compile'
namespace :build do
  EXT = "ferret_ext.so"
  EXT_SRC = FileList["../c/src/*.[c]", "../c/include/*.h",
                     "../c/lib/libstemmer_c/src_c/*.[ch]",
                     "../c/lib/libstemmer_c/runtime/*.[ch]",
                     "../c/lib/libstemmer_c/libstemmer/*.[ch]",
                     "../c/lib/libstemmer_c/include/libstemmer.h"]
  EXT_SRC.exclude('../c/**/ind.[ch]')

  EXT_SRC_DEST = EXT_SRC.map {|fn| File.join("ext", File.basename(fn))}
  SRC = FileList["ext/*.[ch]", EXT_SRC_DEST].uniq

  CLEAN.include     ['**/*.o', '**/*.obj', '.config', 'ext/cferret.c']
  CLOBBER.include   ['doc/api', 'ext/*.so', 'ext/Makefile', EXT_SRC_DEST]

  # The following block creates file tasks for all of the c files. They
  # belong in the ../c directory in source the working copy and they need
  # to be linked to in the ext directory
  EXT_SRC.each do |fn|
    dest_fn = File.join("ext", File.basename(fn))
    file dest_fn => fn do |t|
      safe_ln fn, dest_fn

      if fn =~ /stemmer/
        # flatten the directory structure for lib_stemmer
        open(dest_fn) do |in_f|
          open(dest_fn + ".out", "w") do |out_f|
            in_f.each do |line|
              out_f.write(line.sub(/(#include ["<])[.a-z_\/]*\//, '\1'))
            end
          end
        end
        mv dest_fn + ".out", dest_fn
      end
    end
  end if File.exists?("../c")

  desc "Build the extension (ferret_ext.so). You'll need a C compiler and Make."
  task :compile => ["ext/#{EXT}"] + SRC

  file "ext/#{EXT}" => ["ext/Makefile"] do
    cp "ext/inc/lang.h", "ext/lang.h"
    cp "ext/inc/threading.h", "ext/threading.h"
    cd "ext"
    if (/mswin/ =~ RUBY_PLATFORM) and ENV['make'].nil?
      begin
        sh "nmake"
      rescue Exception => e
        path = ':\Program Files\Microsoft Visual Studio\VC98\Bin\VCVARS32.BAT'
        if File.exists? "f#{path}"
          sh "f#{path}"
        elsif File.exists? "c#{path}"
          sh "c#{path}"
        else
          say
          say "***************************************************************"
          say "You need to have Visual C++ 6 to build Ferret on Windows."
          say "If you have it installed, you may need to run;"
          say ' C:\Program Files\Microsoft Visual Studio\VC98\Bin\VCVARS32.BAT'
          say "***************************************************************"
          say
          raise e
        end
        sh "nmake"
      end
    else
      sh "make"
    end
    cd ".."
  end

  # The following files are special tasks for the C files which are swapped for
  # inclusion in the ruby bindings with the ones used in straight C Ferret.
  #
  # For example, pthread is used in straight C but not in the Ruby bindings.
  file "ext/lang.h" => ["ext/inc/lang.h"] do
    rm_f "ext/lang.h"
    cp "ext/inc/lang.h", "ext/lang.h"
  end

  file "ext/threading.h" => ["ext/inc/threading.h"] do
    rm_f "ext/threading.h"
    cp "ext/inc/threading.h", "ext/threading.h"
  end

  file "ext/Makefile" => SRC do
    cd "ext"
    `ruby extconf.rb`
    cd ".."
  end
end

##############################################################################
# Testing
##############################################################################

namespace :test do
  desc "Run tests with Valgrind"
  task :valgrind do
    sh "valgrind --suppressions=ferret_valgrind.supp " +
       "--leak-check=yes --show-reachable=yes " +
       "-v ruby test/unit/index/tc_index_reader.rb"
  end

  desc "Run all tests"
  task :all => [ :units ]

  desc "run unit tests in test/unit"
  Rake::TestTask.new("units" => :build) do |t|
    t.libs << "test/unit"
    t.pattern = 'test/unit/t[cs]_*.rb'
    t.verbose = true
  end
  task :unit => :units
end

##############################################################################
# Documentation
##############################################################################

desc "Generate API documentation"
task :doc => 'doc:rdoc'
namespace :doc do
  desc "Generate documentation for the application"
  $rd = Rake::RDocTask.new do |rdoc|
    rdoc.rdoc_dir = 'doc/api'
    rdoc.title    = "Ferret Search Library Documentation"
    rdoc.options << '--line-numbers'
    rdoc.options << '--inline-source'
    rdoc.options << '--charset=utf-8'
    rdoc.rdoc_files.include('README')
    rdoc.rdoc_files.include('TODO')
    rdoc.rdoc_files.include('TUTORIAL')
    rdoc.rdoc_files.include('MIT-LICENSE')
    rdoc.rdoc_files.include('lib/**/*.rb')
    rdoc.rdoc_files.include('ext/r_*.c')
    rdoc.rdoc_files.include('ext/ferret.c')
  end

  desc "Look for TODO and FIXME tags in the code"
  task :todo do
    FileList['**/*.rb', 'ext/*.[ch]'].egrep /[#*].*(FIXME|TODO|TBD)/i
  end
end

##############################################################################
# Packaging
##############################################################################

PKG_FILES = FileList[
  'setup.rb',
  '[-A-Z]*',
  'lib/**/*.rb', 
  'lib/**/*.rhtml', 
  'lib/**/*.css', 
  'lib/**/*.js', 
  'test/**/*.rb',
  'test/**/wordfile',
  'rake_utils/**/*.rb',
  'Rakefile',
  SRC
]

spec = Gem::Specification.new do |s|
  
  #### Basic information.
  s.name = 'ferret'
  s.version = Ferret::VERSION
  s.summary = "Ruby indexing library."
  s.description = "Ferret is a super fast, highly configurable search library."

  #### Dependencies and requirements.
  s.add_dependency('rake')
  s.files = PKG_FILES.to_a
  s.extensions << "ext/extconf.rb"
  s.require_path = 'lib'
  s.bindir = 'bin'
  s.executables = ['ferret-browser']
  s.default_executable = 'ferret-browser'

  #### Author and project details.
  s.author = "David Balmain"
  s.email = "dbalmain@gmail.com"
  s.homepage = "http://ferret.davebalmain.com/trac"
  s.rubyforge_project = "ferret"

  s.has_rdoc = true
  s.extra_rdoc_files = $rd.rdoc_files.reject { |fn| fn =~ /\.rb$/ }.to_a
  s.rdoc_options <<
    '--title' <<  'Ferret -- Ruby Search Library' <<
    '--main' << 'README' << '--line-numbers' <<
    'TUTORIAL' << 'TODO'

  if RUBY_PLATFORM =~ /mswin/
    s.files = PKG_FILES.to_a + ["ext/#{EXT}"]
    s.extensions.clear
    s.platform = Gem::Platform::WIN32
  else
    s.platform = Gem::Platform::RUBY
  end
end

package_task = Rake::GemPackageTask.new(spec) do |pkg|
  unless RUBY_PLATFORM =~ /mswin/
    pkg.need_zip = true
    pkg.need_tar = true
  end
end


if ENV['FERRET_DEV']
  ##############################################################################
  # Releasing
  ##############################################################################

  desc "Generate and upload a new release"
  task :release => 'release:release'
  namespace :release do
    task :release => [
      :status_check,
      'test:all',
      :update_version,
      :package,
      :tag] do
      say 
      say "**************************************************************"
      say "* Release #{Ferret::VERSION} Complete."
      say "* Packages ready to upload."
      say "**************************************************************"
      say 
      reversion("lib/ferret_version.rb")
    end

    # Validate that everything is ready to go for a release.
    task :status_check do
      # Are all source files checked in?
      data = `svn -q --ignore-externals status`
      unless data =~ /^$/
        fail "'svn -q status' is not clean ... do you have unchecked-in files?"
      end
      
      say "No outstanding checkins found ... OK"
    end

    def reversion(fn)
      new_version = nil
      begin
        print "Ferret is currently at #{Ferret::VERSION}. What version now? "
        new_version = gets.chomp!
      end until prompt("Change to version #{new_version}?")
      
      open(fn) do |ferret_in|
        open(fn + ".new", "w") do |ferret_out|
          ferret_in.each do |line|
            if line =~ /^  VERSION\s*=\s*/
              ferret_out.puts "  VERSION = '#{new_version}'"
            else
              ferret_out.puts line
            end
          end
        end
      end
      mv fn + ".new", fn
      sh %{svn ci -m "Updated to version #{new_version}" lib/ferret/version.rb}
    end

    # Tag all the SVN files with the latest release number
    task :tag => :status_check do
      reltag = "REL-#{Ferret::VERSION}"
      reltag << ENV['REUSE'] if ENV['REUSE']
      say "Tagging SVN with [#{reltag}]"
      if ENV['RELTEST']
        say "Release Task Testing, skipping SVN tagging. Would do the following;"
        say %{svn copy -m "creating release #{reltag}" svn://www.davebalmain.com/ferret/trunk svn://www.davebalmain.com/ferret/tags/#{reltag}}
      else
        sh %{svn copy -m "creating release #{reltag}" svn://www.davebalmain.com/ferret/trunk svn://www.davebalmain.com/ferret/tags/#{reltag}}
      end
    end
  end
end
   



#
# In case I ever need to add another racc parser, here's how
#
# # Make Parsers ---------------------------------------------------------------
# 
# RACC_SRC = FileList["lib/**/*.y"]
# 
# task :parsers => RACC_OUT
# rule(/\.tab\.rb$/ => [proc {|tn| tn.sub(/\.tab\.rb$/, '.y')}]) do |t|
#   sh "racc #{t.source}" 
# end
